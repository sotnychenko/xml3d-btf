\chapter{Conclusions and Future Work}
\label{chapter:conclusions}
 Bidirectional Texture Functions becoming more and more popular for the realistic rendering.
Until now lots of research has been done in this field. 
However, BTFs are still rarely used in the graphic applications, 
due to  sophisticated measurement of BTFs and the large size of the acquired data.
Thus, BTFs are still staying as the state of the art in computer graphics. 


\section{Summary}
In this work we showed that the Bidirectional Texture Function is a powerful texture representation and 
that the real-time frame rate can be achieved during rendering.
We looked into different compression methods available for BTFs and decided to work with PCA.
We came up with a flexible PCA compression method based on previous works.
We perform PCA on the chosen number of neighbour camera directions.
This allows for achieving a compression ratio up to $1:100$, while having a small decompression error by adapting the number of principal components.

We have built a WebGL framework for rendering 3D objects realistically using Bidirectional Texture Functions.
To reduce the delay caused by the BTF data transmission from the server to the client we use WebSockets.
By streaming the principal components we are able to show intermediate rendering results of the textured 3D object.
The first previews of the rendering are immediately available for the user.

Finally, visual quality, memory usage and computational effort can be be balanced  per-application by choosing the suitable parameters for the compression.


\section{Future work}
\label{section:future_work}
Based on our results several directions for the future work can be made.
First of all, improvement can be made in regards of the scenes that involve several BTFs.
The multiple streaming of BTFs can be implemented. We showed that we can render 3 BTFs at the same time with real-time frame rate.
Secondly, several optimizations of the BTF shader performance can be made.
For instance, it is possible to reduce some of the calculations such as computation of the interpolation weights. 
They can be precomputed and stored in a cube-map \cite{haindl}.
Other calculations such as computation of the bidirectional normals can be precomputed and stored along with a 3D mesh.

Last but not least, there is a room for further compression.
 For instance, it can be achieved by compressing the PCA weights with the following techniques: wavelet compression \cite{webglbtfstreaming}, entropy encoding \cite{gpu_gems} and 
 vector quantization \cite{vectorquantization}.
However, the decompression cost can grow, but it can be worth if the memory savings are inevitable. 